<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html 
     PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>Module: YuiTree::ClassMethods</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Script-Type" content="text/javascript" />
  <link rel="stylesheet" href="../.././rdoc-style.css" type="text/css" media="screen" />
  <script type="text/javascript">
  // <![CDATA[

  function popupCode( url ) {
    window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
  }

  function toggleCode( id ) {
    if ( document.getElementById )
      elem = document.getElementById( id );
    else if ( document.all )
      elem = eval( "document.all." + id );
    else
      return false;

    elemStyle = elem.style;
    
    if ( elemStyle.display != "block" ) {
      elemStyle.display = "block"
    } else {
      elemStyle.display = "none"
    }

    return true;
  }
  
  // Make codeblocks hidden by default
  document.writeln( "<style type=\"text/css\">div.method-source-code { display: none }</style>" )
  
  // ]]>
  </script>

</head>
<body>



    <div id="classHeader">
        <table class="header-table">
        <tr class="top-aligned-row">
          <td><strong>Module</strong></td>
          <td class="class-name-in-header">YuiTree::ClassMethods</td>
        </tr>
        <tr class="top-aligned-row">
            <td><strong>In:</strong></td>
            <td>
                <a href="../../files/vendor/plugins/yui_tree/lib/yui_tree_rb.html">
                vendor/plugins/yui_tree/lib/yui_tree.rb
                </a>
        <br />
            </td>
        </tr>

        </table>
    </div>
  <!-- banner header -->

  <div id="bodyContent">



  <div id="contextContent">



   </div>

    <div id="method-list">
      <h3 class="section-bar">Methods</h3>

      <div class="name-list">
      <a href="#M000006">uses_yui_tree</a>&nbsp;&nbsp;
      <a href="#M000007">yui_tree_handled_xhr_request?</a>&nbsp;&nbsp;
      </div>
    </div>

  </div>


    <!-- if includes -->

    <div id="section">





      


    <!-- if method_list -->
    <div id="methods">
      <h3 class="section-bar">Public Instance methods</h3>

      <div id="method-M000006" class="method-detail">
        <a name="M000006"></a>

        <div class="method-heading">
          <a href="#M000006" class="method-signature">
          <span class="method-name">uses_yui_tree</span><span class="method-args">( tree_options = {}, filter_options = {} )</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Define the &quot;<a
href="ClassMethods.html#M000006">uses_yui_tree</a>&quot; class method,
which sets up instance variables &quot;<tt>@yui_tree_options</tt>&quot; and
&quot;<tt>@<a href="ClassMethods.html#M000006">uses_yui_tree</a></tt>&quot;
within any controller calling the method. See &quot;self.included&quot; in
the plugin code for more information.
</p>
<p>
The &quot;<a href="ClassMethods.html#M000006">uses_yui_tree</a>&quot;
method can be passed two optional options hashes. The first specifies
options for the YUI tree. The second is passed directly to the Rails <a
href="http://api.rubyonrails.org/classes/ActionController/Filters/ClassMethods.html#M000526">before_filter</a>
method as filter options and this lets you state conditions for which
&quot;<a href="ClassMethods.html#M000006">uses_yui_tree</a>&quot; applies
(e.g. &quot;<tt>:only =&gt; &#8230;</tt>&quot; for only certain actions or
&quot;<tt>:except =&gt; &#8230;</tt>&quot; for all actions except those
listed). See the Rails <a
href="http://api.rubyonrails.org/classes/ActionController/Filters/ClassMethods.html">filter API documentation</a>
for full details.
</p>
<p>
Most options for YUI trees can be specified in any of three places:
</p>
<ol>
<li>In the YAML configuration file.

</li>
<li>In a call to &quot;<a
href="ClassMethods.html#M000006">uses_yui_tree</a>&quot; from a controller.

</li>
<li>In a call to the &quot;<a
href="YuiTreeHelper.html#M000005">YuiTree::YuiTreeHelper.yui_tree</a>&quot;
helper method from a view.

</li>
</ol>
<p>
Options in the YAML file are application-global and overriden by those
specified in a controller, which are controller-global and in turn
overriden by local options given to helper method calls in views.
</p>
<p>
Some options only make sense if specified in the YAML configuration file
and so cannot be specified elsewhere. When installed the plugin writes a
default configuration file in &quot;config/yui_tree.yml&quot;; see this for
further information on the option meainings:
</p>
<ul>
<li><tt>:version</tt>

</li>
<li><tt>:javascript_base_uri</tt>

</li>
<li><tt>:additional_yui_javascripts</tt> (an optional item)

</li>
</ul>
<p>
The following options usually only make sense if given in the YAML
configuration file and have default values written there, but they can be
specified per-controller or in each helper call in views if you really want
to do that:
</p>
<ul>
<li><tt>:xhr_timeout</tt>

</li>
<li><tt>:div_class</tt> (the class assigned to any DIV into which a YUI tree is
built)

</li>
</ul>
<p>
These options can appear in the YAML file or here only, but not in helper
calls for individual views:
</p>
<ul>
<li><tt>:body_class</tt> (a class name added to any existing class name(s) on
the BODY element of the HTML document) - if
&quot;<tt>yui-skin-sam</tt>&quot; is used then CSS files for this skin will
be included automatically, else you must manually ensure that all relevant
CSS resources are included.

</li>
</ul>
<p>
Other options must be specified in calls to &quot;<a
href="ClassMethods.html#M000006">uses_yui_tree</a>&quot;, or to a helper
function like &quot;<a
href="YuiTreeHelper.html#M000005">YuiTree::YuiTreeHelper.yui_tree</a>&quot;
as they have no default values. You could put them into the YAML file but
due to the nature of the options it is very likely that you&#8216;ll
specify them in method calls instead. In fact it&#8216;s more likely that
you will want to specify them in calls made in views rather than here in
&quot;<a href="ClassMethods.html#M000006">uses_yui_tree</a>&quot;, but you
can establish Controller-global defaults by specifying the options here if
you find this useful.
</p>
<table>
<tr><td valign="top"><tt>:root_model</tt>:</td><td>If your model supports tree/nested-set like behaviour - for example, if
your model declares &quot;<tt>acts_as_nested_set</tt>&quot; via the <a
href="http://github.com/collectiveidea/awesome_nested_set/">Awesome Nested Set</a>
plugin - then specify the root model class here (e.g specify
&quot;<tt>:root_model =&gt; Location</tt>&quot; or &quot;<tt>:root_model
=&gt; Category</tt>&quot;) as a Controller-global default. Nested set
behaviour assumes a class method called &quot;roots&quot; which takes no
parameters and returns an array of model instances which are tree roots;
and an instance method &quot;leaf?&quot; which also takes no parameters and
returns &#8216;<tt>true</tt>&#8217; if the instance has no children (is a
leaf node), else returns &#8216;<tt>false</tt>&#8217;.

<p>
The root model is used by YUI tree creation code (e.g. see helper method
&quot;<a
href="YuiTreeHelper.html#M000005">YuiTree::YuiTreeHelper.yui_tree</a>&quot;)
to generate the root data set for the initial tree view. Alternatively,
specify this when you make the call to e.g. &quot;<a
href="YuiTreeHelper.html#M000005">YuiTree::YuiTreeHelper.yui_tree</a>&quot;
if you don&#8216;t want to set a default here. By default the helper code
calls an instance method called &quot;name&quot; to obtain label text for
the tree nodes. Use the &quot;<tt>:root_title_method</tt>&quot; option (see
below) to specify a different method name if necessary.
</p>
<p>
The root and child items can be sorted in various ways. See method &quot;<a
href="ClassMethods.html#M000007">yui_tree_handled_xhr_request?</a>&quot;
method for further information.
</p>
<p>
If you want to supply the collection of root objects yourself, rather than
using a &quot;<tt>:root_model</tt>&quot; (see above) and its
&quot;roots&quot; class method, you can do so when building the tree in a
view through a call to the &quot;<a
href="YuiTreeHelper.html#M000005">YuiTree::YuiTreeHelper.yui_tree</a>&quot;
helper method. See its &quot;<tt>:root_collection</tt>&quot; option for
details. Whenever you need to assemble an array of objects to be used as
roots or children, you must always build those objects with the &quot;<a
href="../YuiTree.html#M000001">YuiTree.make_node_object</a>&quot; method.
</p>
</td></tr>
<tr><td valign="top"><tt>:root_title_method</tt>:</td><td>If using &quot;<tt>:root_model</tt>&quot; (see above) but with a model
which uses something other than a &quot;name&quot; method to return text
for showing in tree nodes, then specify the alternative method&#8216;s name
here as a symbol. It must be an instance method for the model in question
and should return a non-empty string.

</td></tr>
<tr><td valign="top"><tt>:xhr_url_method</tt>:</td><td>Name of a method which will be invoked to get the <b>prefix</b> of a URL
used to fetch more tree data (when parent nodes are expanded for the first
time). This is usually a path to a controller&#8216;s &#8216;index&#8217;
action, e.g. &quot;<tt>:locations_path</tt>&quot; or
&quot;<tt>:categories_path</tt>&quot;. The corresponding Controller action
must return an array of child data. It can use the &quot;<a
href="ClassMethods.html#M000007">yui_tree_handled_xhr_request?</a>&quot;
method to do this or use entirely custom code. It must return an array of
child data as described above (see &quot;<tt>:root_model</tt>&quot;),
generating array entries with the &quot;<a
href="../YuiTree.html#M000001">YuiTree.make_node_object</a>&quot; method.
The parent&#8216;s database ID is delivered to the controller action via
the &quot;params&quot; hash under key &quot;<tt>:tree_parent_id</tt>&quot;
and may have a string, symbol or integer value type.

</td></tr>
</table>
<p>
Some options are likely to be set per-tree but do have default values:
</p>
<table>
<tr><td valign="top"><tt>:select_leaf_only</tt>:</td><td>Set to &#8216;<tt>true</tt>&#8217; if leaves (nodes without children) can
be selected but parents cannot, else &#8216;<tt>false</tt>&#8217;. Has an
internal default value of &#8216;<tt>false</tt>&#8217; (i.e. can select
anything).

</td></tr>
</table>
<p>
A few YUI tree options can be set as global defaults when making calls to
&quot;<a href="ClassMethods.html#M000006">uses_yui_tree</a>&quot;, but such
defaults only make sense if you use a single tree in any of the containing
controller&#8216;s views. For example, the option giving the ID of
enclosing DIV inside which the tree is built falls into this category,
since no two elements in a valid HTML document are allowed to have the same
ID. It is up to you where you choose to specify these options - here, or
individual calls to &quot;<a
href="YuiTreeHelper.html#M000005">YuiTree::YuiTreeHelper.yui_tree</a>&quot;.
</p>
<table>
<tr><td valign="top"><tt>:div_id</tt>:</td><td>ID given to the DIV container into which trees are built. Only specify this
as a controller-global default if you are only going to use one tree
control in any given view, else more than one DIV container for more than
one tree view would have the same ID; or make very sure that any views
using more than one tree view specify overriding DIV IDs in those
views&#8217; calls to &quot;<a
href="YuiTreeHelper.html#M000005">YuiTree::YuiTreeHelper.yui_tree</a>&quot;.

</td></tr>
<tr><td valign="top"><tt>:div_class</tt>:</td><td>As &quot;<tt>:div_id</tt>&quot;, but even less frequently used! Usually you
will want application-wide styles to apply to trees via CSS and thus
specify a single application-global class name in the YUI tree
plugin&#8216;s YAML configuration file, rather than specifying a
controller-global value here, or even a per-tree value in indivdual calls
to &quot;<a
href="YuiTreeHelper.html#M000005">YuiTree::YuiTreeHelper.yui_tree</a>&quot;.
Nonetheless, the facility exists to use any of those three approaches
should they prove useful to you.

</td></tr>
<tr><td valign="top"><tt>:target_form_field_id</tt>:</td><td>Whenever a node is selected, its database ID is written as a value of the
&quot;<tt>value</tt>&quot; (sic.) attribute of the HTML element identified
by this option so that a related form submission will contain the selected
ID. The field is usually a hidden INPUT element.

<p>
Although the tree has a multiple selection mode (see the documentation for
&quot;<a
href="YuiTreeHelper.html#M000005">YuiTree::YuiTreeHelper.yui_tree</a>&quot;
for details), by default it assumes that you always want to ultimately let
the user select a single item in the tree and have that item&#8216;s
database ID passed back to a controller in a related form submission.
</p>
<p>
A value of 0 may indicate that a blank entry is use and has been selected.
See option &quot;<tt>:include_blank</tt>&quot; in helper method &quot;<a
href="YuiTreeHelper.html#M000005">YuiTree::YuiTreeHelper.yui_tree</a>&quot;.
</p>
<p>
An empty string indicates that no nodes were highlighted at all. If you
allow such things you should probably interpret this the same as the user
explicitly selecting a blank entry. It&#8216;s good to allow both as it
isn&#8216;t too friendly to assume the user will mean that deselecting all
nodes means &quot;none/blank&quot;; it&#8216;s good to have an explicit
entry for that. You can still fault a no-selection form submission from the
controller if the target form field value is empty rather than zero, should
you wish to do so.
</p>
</td></tr>
<tr><td valign="top"><tt>:target_name_field_id</tt>:</td><td>Optional; if included, then when a node is selected, its display text is
written as innerHTML inside the identified element. This lets you show the
user which node was selected by its text, as well as by the
TreeView&#8216;s own highlight mechanism. This is handy if you&#8216;re
worried that a selected node in a collapsed branch remains selected, albeit
invisibly - a TreeView implementation quirk, it seems.

<p>
If you specify a value for the &quot;<tt>:include_blank</tt>&quot; option
in a call to helper method &quot;<a
href="YuiTreeHelper.html#M000005">YuiTree::YuiTreeHelper.yui_tree</a>&quot;,
then note that the specified string will be written into the name field if
either a &quot;blank&quot; tree entry item is explicitly selected, or if
all items in the tree are entirely deselected. This goes back to the idea
in &quot;<tt>:target_form_field_id</tt>&quot; above of a zero ID value, or
a blank ID value, being usually treated as the same thing; but again, the
controller can always treat the two conditions as distinct from one another
if it so wishes.
</p>
</td></tr>
</table>
<h2>Example</h2>
<pre>
  # Location model &quot;acts_as_nested_set&quot;; uses Awesome Nested Set plugin;
  # thus has &quot;roots&quot; and &quot;leaf?&quot; methods which act as expected. Location
  # objects have a displayable name property in &quot;name&quot;.

  uses_yui_tree(
    { :root_model =&gt; Location, :xhr_url_method =&gt; :locations_path },
    { :only =&gt; [ :edit, :update ] }
  )
</pre>
<p>
This prepares the Controller for a YUI tree using a &quot;Location&quot;
model. The tree will obtain new data by a JSON XHR request to the URL
returned by a call to &quot;locations_path&quot; with &quot;.js&quot; added
as a suffix. Only the &quot;:edit&quot; and &quot;:update&quot; actions can
use the tree. Listing both of these actions in the &quot;:only&quot; clause
is vital since the Controller&#8216;s &quot;update&quot; code might
re-render the &quot;edit&quot; view (and thus the tree) because of form
validation errors. Alternatively use &quot;:exclude&quot; rather than
&quot;:only&quot;, or omit such a clause altogether to prepare all the
controller&#8216;s views for YUI trees.
</p>
<p>
An XHR URL method of &quot;locations_path&quot; will (assuming sane
routes!) lead to an &quot;index&quot; action of a controller for the
Location model. The index method must be aware of the YUI tree JSON
requests - see &quot;<a
href="ClassMethods.html#M000007">yui_tree_handled_xhr_request?</a>&quot; or
use the usual Rails &quot;<tt>respond_to do |format| &#8230; format.js do
&#8230;</tt>&quot; construct.
</p>
<pre>
  def index
    return if yui_tree_handled_xhr_request?( Location );
    # ...other processing code...
  end
</pre>
<p>
A helper method such as &quot;<a
href="YuiTreeHelper.html#M000005">YuiTree::YuiTreeHelper.yui_tree</a>&quot;
must be invoked somewhere in the &quot;:edit&quot; action&#8216;s view
(e.g. in &quot;edit.html.erb&quot;) so that the tree actually gets built:
</p>
<pre>
  &lt;%= hidden_field_tag( 'foo', '[currently selected item ID here]' ) %&gt;
  &lt;%= yui_tree( :target_form_field_id =&gt; 'foo' ) %&gt;
</pre>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000006-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000006-source">
<pre>
     <span class="ruby-comment cmt"># File vendor/plugins/yui_tree/lib/yui_tree.rb, line 247</span>
247:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">uses_yui_tree</span>( <span class="ruby-identifier">tree_options</span> = {}, <span class="ruby-identifier">filter_options</span> = {} )
248:       <span class="ruby-identifier">proc</span> = <span class="ruby-constant">Proc</span>.<span class="ruby-identifier">new</span> <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span> <span class="ruby-identifier">c</span> <span class="ruby-operator">|</span>
249:         <span class="ruby-identifier">c</span>.<span class="ruby-identifier">instance_variable_set</span>( <span class="ruby-identifier">:@yui_tree_options</span>, <span class="ruby-identifier">tree_options</span> )
250:         <span class="ruby-identifier">c</span>.<span class="ruby-identifier">instance_variable_set</span>( <span class="ruby-identifier">:@uses_yui_tree</span>,    <span class="ruby-keyword kw">true</span>         )
251:       <span class="ruby-keyword kw">end</span>
252: 
253:       <span class="ruby-identifier">before_filter</span>( <span class="ruby-identifier">proc</span>, <span class="ruby-identifier">filter_options</span> )
254: 
255:       <span class="ruby-comment cmt"># See the dummy, static version of &quot;yui_tree_handled_xhr_request?&quot; below</span>
256:       <span class="ruby-comment cmt"># for documentation.</span>
257:       <span class="ruby-comment cmt">#</span>
258:       <span class="ruby-keyword kw">self</span>.<span class="ruby-identifier">class_eval</span> <span class="ruby-value str">%(
259:         define_method( :yui_tree_handled_xhr_request? ) do | model, *optional |
260:           result = false
261: 
262:           # WARNING: By default Rails treats XHR requests as &quot;.js&quot; format, if
263:           # no other format indication (e.g. filename extension, very specific
264:           # HTTP Accept header) exists. As a result this code can be run for
265:           # other XHR requests coming into your controller even though you
266:           # think it ought not to be. Hence the &quot;params.has_key?&quot; check, to try
267:           # and guard against accidental execution.
268: 
269:           if ( request.xhr? &amp;&amp; params.has_key?( :tree_parent_id ) )
270:             respond_to do | format |
271:               format.js do
272: 
273:                 # Use find_by_id() rather than just find() to avoid an exception if
274:                 # the item cannot be located.
275: 
276:                 parent = model.find_by_id( params[ :tree_parent_id ] )
277: 
278:                 if ( parent.nil? )
279:                   render :json =&gt; []
280:                 else
281:                   children = parent.children()
282: 
283:                   if ( model.respond_to?( :apply_default_sort_order ) )
284:                     model.apply_default_sort_order( children )
285:                   end
286: 
287:                   children.map!() do | child |
288:                     YuiTree::make_node_object(
289:                       child.id,
290:                       child.send( optional[ 0 ] || YuiTree::YUI_TREE_DEFAULT_TITLE_METHOD ),
291:                       child.send( optional[ 1 ] || :leaf? )
292:                     )
293:                   end
294: 
295:                   render :json =&gt; children
296:                 end
297: 
298:                 result = true
299: 
300:               end # format.js do
301:             end   # respond_to do | format |
302:           end     # if ( request.xhr? ... )
303: 
304:           result # Can't do &quot;return result&quot;; leads to ThreadError exception.
305: 
306:         end # define_method...
307:       )</span>
308:     <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000007" class="method-detail">
        <a name="M000007"></a>

        <div class="method-heading">
          <a href="#M000007" class="method-signature">
          <span class="method-name">yui_tree_handled_xhr_request?</span><span class="method-args">()</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
When the tree calls back via AJAX and needs some children to fill in a tree
branch, call here to return appropriate data. Pass in the model to find
from (e.g. Category, Location - a class, not a string or symbol), then
optionally the name of the model instance method used to obtain the text to
show for each node (default is &quot;name&quot;) and the name of a method
used to find out if the item is a leaf (default is &quot;leaf?&quot;) - it
should return &#8216;true&#8217; if so, else &#8216;false&#8217;. Models
which &quot;act_as_nested_set&quot; using the <a
href="http://github.com/collectiveidea/awesome_nested_set/tree/master">Awesome Nested Set</a>
plug-in are compatible with the defaults.
</p>
<p>
If you want the tree order items automatically sorted then add a class
method called &quot;apply_default_sort_order&quot; to your model. This is
passed an array of model object instances and should sort the array
in-place (e.g. with the Array &quot;sort!&quot; method). The method&#8216;s
return value is ignored. If the model has no
&quot;apply_default_sort_order&quot; method then the collection retrieved
from the database is left in default sort order. If you have simple
requirements then using a call to Rails&#8217; &quot;<a
href="http://api.rubyonrails.org/classes/ActiveRecord/Base.html#M002313">default_scope</a>&quot;
method from your model is the most efficient way to achieve sorted results.
For example, in your model issue:
</p>
<pre>
  default_scope( { :order =&gt; 'name DESC' } )
</pre>
<p>
&#8230;to have all collections of that model returned by finder methods
sorted in descending order by a &quot;name&quot; field by default. This
applies to <em>all</em> finds done by your application, not just those
related to YUI trees, so use the &quot;apply_default_sort_order&quot;
approach to restrict the ordering to YUI tree views only.
</p>
<h2>Example</h2>
<p>
A controller example inside an action which gets invoked when the XHR
request comes in:
</p>
<pre>
  def action_name
    return if yui_tree_handled_xhr_request?( Location, :title, :isLeaf? )
    # ...rest of normal action code...
  end
</pre>
<p>
This would handle YUI tree requests for a Location model using method
&quot;title&quot; (rather than the default of &quot;name&quot;) to obtain
the human-readable names of locations and method &quot;isLeaf?&quot;
(rather than the default of &quot;leaf?&quot;) to determine whether or not
the item is at the end of a branch.
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000007-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000007-source">
<pre>
     <span class="ruby-comment cmt"># File vendor/plugins/yui_tree/lib/yui_tree.rb, line 354</span>
354:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">yui_tree_handled_xhr_request?</span>
355:       <span class="ruby-comment cmt"># This method is generated dynamically at run-time, the dynamic version</span>
356:       <span class="ruby-comment cmt"># overwriting this one. The method here exists purely so that the RDoc</span>
357:       <span class="ruby-comment cmt"># documentation generator will create documentation for the method.</span>
358:       <span class="ruby-comment cmt"># Please see the implementation of &quot;uses_yui_tree&quot; above to see the code</span>
359:       <span class="ruby-comment cmt"># for the dynamically generated method.</span>
360:     <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>


    </div>


  </div>


<div id="validator-badges">
  <p><small><a href="http://validator.w3.org/check/referer">[Validate]</a></small></p>
</div>

</body>
</html>