<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html 
     PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>File: README</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Script-Type" content="text/javascript" />
  <link rel="stylesheet" href="../../../.././rdoc-style.css" type="text/css" media="screen" />
  <script type="text/javascript">
  // <![CDATA[

  function popupCode( url ) {
    window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
  }

  function toggleCode( id ) {
    if ( document.getElementById )
      elem = document.getElementById( id );
    else if ( document.all )
      elem = eval( "document.all." + id );
    else
      return false;

    elemStyle = elem.style;
    
    if ( elemStyle.display != "block" ) {
      elemStyle.display = "block"
    } else {
      elemStyle.display = "none"
    }

    return true;
  }
  
  // Make codeblocks hidden by default
  document.writeln( "<style type=\"text/css\">div.method-source-code { display: none }</style>" )
  
  // ]]>
  </script>

</head>
<body>



  <div id="fileHeader">
    <h1>README</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>vendor/plugins/yui_tree/README
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Wed Dec 09 22:04:08 +0000 2009</td>
    </tr>
    </table>
  </div>
  <!-- banner header -->

  <div id="bodyContent">



  <div id="contextContent">

    <div id="description">
      <h1>YUI Tree</h1>
<p>
The YUI Tree plugin integrates the Yahoo User Interface (YUI) library
TreeView component into a Rails application. For more information on YUI
and TreeView, please see <a
href="http://developer.yahoo.com/yui/examples/treeview">developer.yahoo.com/yui/examples/treeview</a>.
</p>
<p>
At the time of writing this plugin is designed to work with YUI version
2.7.0.
</p>
<h2>Installation</h2>
<p>
From the root of the Rails application to which you wish to add the plugin,
run this command:
</p>
<pre>
  script/plugin install svn://rubyforge.org/var/svn/yuitree/yui_tree
</pre>
<p>
If you wish to install the API documentation into &quot;doc/plugins&quot;,
next run:
</p>
<pre>
  rake doc:plugins:yui_tree
</pre>
<h2>Usage</h2>
<h3>Example 1: Single model &quot;nested set&quot; use</h3>
<p>
Set the parent of an instance of a hierarchical taxonomy model called
Category.
</p>
<h4>models/category.rb</h4>
<p>
Use of the YUI tree plugin is simplest when it is used to represent a
single model with nested set characteristics, for example through the
Awesome Nested Set plug-in (see <a
href="http://github.com/collectiveidea/awesome_nested_set">github.com/collectiveidea/awesome_nested_set</a>):
</p>
<pre>
  class Category &lt; ActiveRecord::Base
    acts_as_nested_set()

    # Later example code for the view uses this custom &quot;to_s&quot; method
    # so that &quot;&lt;%= some_category %&gt;&quot; will write the name of the category
    # into the view, or write nothing if some_category is &quot;nil&quot;, without
    # needing any &quot;nil?&quot; checks (c.f. using &quot;&lt;%= some_category.name %&gt;&quot;).

    def to_s
      name
    end
  end
</pre>
<h4>controllers/category_controller.rb</h4>
<p>
In the Controller, note that YUI tree is used. You can use Rails
ActionController::Filters semantics here (e.g. as in
&quot;before_filter&quot;):
</p>
<pre>
  class CategoryController &lt; ApplicationController
    uses_yui_tree( { :xhr_url_method =&gt; :categories_path }, {} )

    # ...where &quot;{}&quot; might be :only   =&gt; [ :new, :create, :edit, :update ] )
    #                     or :except =&gt; [ :index                        ] )
    #
    # ...or some other valid filter options hash, or even simply omitted
    # entirely to include the tree resources in all views unconditionally.

    def index
      return if yui_tree_handled_xhr_request?( Category )

      # ...the rest of a normal 'index' action goes here.
    end
  end
</pre>
<p>
In the above code, we also specify that the XHR requests should go via
&quot;categories_path&quot;, directing them to the controller&#8216;s
&quot;index&quot; method. This method then makes a single-line call to a
YUI tree support method to get data sent back to the tree view if the
request is intended for it, else continue processing as normal. This all
works automatically for nested set-like objects due to the various default
values and method names used by the tree code, described in more detail in
the rest of the API documentation.
</p>
<h4>views/layouts/application.html.erb</h4>
<p>
In the application layout, conditionally include the YUI components. The
&quot;uses_yui_tree&quot; declarations in controllers lead to only those
views which actually use YUI components including the relevant scripts and
stylesheets, improving page load times for views which don&#8216;t need the
tree view.
</p>
<pre>
  &lt;head&gt;
  &lt;%= include_yui_tree_if_used( '  ' ) -%&gt;
  &lt;/head&gt;
</pre>
<p>
The optional parameter to the call above is a string used as prefix on each
line of output. Usually this is a series of spaces so that the output HTML
indentation looks good (if you care about such things!).
</p>
<h4>views/categories/new.html.erb or edit.html.erb</h4>
<p>
Finally, invoke the tree from relevant views. Assuming the controller sets
@category to the new Category or category being edited, then:
</p>
<pre>
  &lt;% form_for( @category ) do | f | %&gt;
    &lt;p&gt;
      &lt;b&gt;&lt;%= label_tag :enclosing_category, 'Parent category' %&gt;:&lt;/b&gt;
      &lt;span id=&quot;selected_item&quot;&gt;&lt;%= @category.parent %&gt;&lt;/span&gt;
      &lt;%= hidden_field_tag :enclosing_category, &quot;#{ @category.parent_id }&quot; %&gt;
    &lt;/p&gt;
    &lt;%=
      parent    = @item.parent
      ancestors = parent.ancestors unless ( parent.nil? )

      yui_tree(
        :target_form_field_id =&gt; 'enclosing_category',
        :target_name_field_id =&gt; 'selected_item',
        :exclude              =&gt; @category,
        :highlight            =&gt; parent,
        :expand               =&gt; ancestors
      )
    %&gt;
  &lt;% end %&gt;
</pre>
<p>
This code writes a label for the &#8216;parent&#8217; field selector, then
writes a SPAN which contains the currently selected parent name (if any).
This is optional. A mandatory hidden field carries the ID of the selected
item. This uses custom form field &quot;enclosing_category&quot; for
reasons described later.
</p>
<p>
Then the tree is written. The ID of the hidden field is given so that the
YUI tree handler code knows where to write the ID of any item selected in
the tree. The optional name field ID of &quot;selected_item&quot; makes the
tree also write the name of the selected item into that element, as
innerHTML. Since the category we are editing or creating cannot be its own
parent, we ask the tree to exclude this item when listing other categories.
If the item already has a parent then the tree needs to be told to select
(highlight) this item by default. Since that parent may lie down in some
branch below the root node (&#8216;trunk&#8217;) level the tree is also
asked to expand the ancestor nodes of that parent.
</p>
<p>
The YUI tree&#8216;s automatic code handles cases where things act as a
nested set, using methods &quot;id&quot; to determine the IDs of objects
for form submissions and &quot;name&quot; to determine the human-readable
names to show in the tree selector. All of this can be overridden for more
complex cases.
</p>
<p>
A complication arises because of the fiddly way which assignments of
parents in something like a tree of categories, where several items will
want to sit at the root/trunk level, must be carried out. One way to tackle
this is to use a custom controller method which assigns the parent and call
it using code along the following lines, in the controller:
</p>
<pre>
  def create
    parent_id  = params[ :enclosing_parent ]
    Category   = Category.new( params[ :category )
    successful = set_parent( @category, parent_id ) do
      @category.save # Note how here we pass a block in to &quot;set_parent&quot;
    end

    if ( successful )
      flash[ :notice ] = 'New category created successfully'
      redirect_to @category
    else
      render :action =&gt; 'new'
    end
  end
</pre>
<p>
Since this is example code, I&#8216;m not including issues such as a web
services XML API in there (compare this with Rails scaffold code, which
does) and display strings are hard-coded (modern Rails applications might
be using the internalisation mechanism instead).
</p>
<p>
The example &quot;set_parent&quot; code is below. It handles changing the
parent of the item, as well as saving it or updating it via calling back to
the block which the caller passes in, atomically. It does that via a
transaction. If any part of the process fails, the database will be rolled
back to a consistent state.
</p>
<pre>
  def set_parent( child, parent_id )
    parent_id = parent_id.to_i

    begin
      child.class.transaction do
        return false unless ( yield() == true )

        if ( parent_id.zero? )
          child.move_to_root()
        else
          child.move_to_child_of( parent_id )
        end
      end

    rescue =&gt; error
      # Report the error, e.g. via 'flash'
      return false

    end

    return true
  end
</pre>
<h3>Example 2: Non-&quot;nested set&quot; or multi-model use</h3>
<p>
For models which do not conform to Acts As Nested Set style semantics, or
to use a tree for multiple models concurrently (e.g. assign Tasks to
Projects, where Task and Project are distinctly different models) then you
will need to provide a controller which serves up data for the XML requests
made by the YUI tree. Consult the API documentation for details. For
real-world example code, have a look at the XML request handler in
TrackRecord, a Rails application which uses a YUI tree to manage Customers,
Projects and Tasks:
</p>
<p>
<a
href="http://trackrecord.rubyforge.org/svn/app/controllers/trees_controller.rb">trackrecord.rubyforge.org/svn/app/controllers/trees_controller.rb</a>
</p>
<h2>Configuration</h2>
<p>
Default settings are held in in &quot;config/yui_editor.yml&quot;. You can
override the editor defaults in each controller with in the
&quot;uses_yui_tree&quot; method call if you wish; see the documentation
for that call for details.
</p>
<h2>Heritage</h2>
<p>
The plugin wrapper concept comes from larsklevan&#8216;s
&quot;yui_editor&quot; plugin:
</p>
<p>
<a
href="http://github.com/larsklevan/yui_editor/tree/master">github.com/larsklevan/yui_editor/tree/master</a>
</p>
<p>
The <a href="../../../../classes/YuiTree.html">YuiTree</a> plugin would not
exist without this component. My thanks go to the author for his hard work.
</p>
<h2>Feedback</h2>
<p>
Please send feedback and questions to ahodgkin@rowing.org.uk
</p>
<h1>Copyright</h1>
<p>
Copyright (c) 2009 Hipposoft (Andrew Hodgkinson). Released under the MIT
license.
</p>

    </div>


   </div>


  </div>


    <!-- if includes -->

    <div id="section">





      


    <!-- if method_list -->


  </div>


<div id="validator-badges">
  <p><small><a href="http://validator.w3.org/check/referer">[Validate]</a></small></p>
</div>

</body>
</html>